0. Итераторы
    - Что это такое?
    - Зачем?
    - Что нужно перегрузить для базовой работы? Что для самого крутого нужно иметь?
1. Что происходит при throw?  Unwinding stack
    - Экстренный выход из функции:
    - Уничтожаются все переменные (в обратном порядке к порядку создания)
    - Выходим из функции без возвращаемого значения
    - Выходим из функции, и дальше по аналогии в другой функции
    - Вплоть до мейна, там std::terminate 
2. [] & at == SegFault & Exception
    - Можно поймать & нельзя поймать..
    - 2 оператора проверяют dynamic_cast (std::bad_cast), new (std::bad_alloc)
3. Лишние копирования в throw [файл](exceptions_1.cpp)
4. Приведение типов в caught [файл](exceptions_2.cpp)
    - с точностью до ковариантных типов
    - и ...? было на лекции *
5. Исключения в конструкторе и деструкторе
    - Чем плохо?
    - Что делать с конструктором?
    - А в деструкторе?
6. **Задача:**
    - Напишите свой класс исключений MyError
    - Перегрузите в нём метод ... печатающий поясняющее сообщение
    - Заведите функцию которая выбрасывает это исключение и обработайте его
7. Атрибут [[nodiscard]]
    - является частью стандарта C++17 и используется для указания компилятору, что значение, возвращаемое функцией или результат конструктора типа, не должно игнорироваться.
    - Если вы вызываете функцию, помеченную атрибутом [[nodiscard]], и не использует возвращаемое ей значение, компилятор выдаст предупреждение.
    - Это особенно полезно для указания на функции, которые возвращают значение, олицетворяющее ошибку или другой важный результат, который не должен быть проигнорирован.
8. std::exception
    - Желательно от него наследоваться 
    - [cppreference](https://en.cppreference.com/w/cpp/error/exception)
    - [на русском](https://metanit.com/cpp/tutorial/6.2.php)
9. О нулевой стоимости исключений:
    - Концепция zero-cost исключений в C++ относится к стратегии реализации механизма исключений, при которой стоимость добавления поддержки исключений в программу минимальна или отсутствует, пока исключения действительно не выбрасываются. Это достигается за счет использования таблиц исключений, которые строятся на этапе компиляции.
    - Как это работает: Вместо того чтобы вставлять проверки исключений и код обработки в каждый участок кода, который может сгенерировать исключение, компилятор использует таблицы для отображения соответствия между местом в программе, где может возникнуть исключение, и соответствующим обработчиком исключений. Эти таблицы используются во время выполнения программы только тогда, когда действительно происходит исключение.
    - Преимущества: Главное преимущество такого подхода заключается в том, что он не накладывает дополнительных затрат на производительность в случаях, когда исключения не генерируются, что является наиболее частым сценарием. Это делает использование исключений в C++ более привлекательным с точки зрения производительности по сравнению с языками программирования, где обработка исключений может вносить заметные накладные расходы даже когда исключения не используются.
    - Недостатки: С другой стороны, когда исключение действительно возникает, обработка может быть дороже по сравнению с кодом, который просто проверяет возвращаемые значения на наличие ошибок, поскольку требуется выполнить поиск в таблице исключений и выполнить развёртку стека.
